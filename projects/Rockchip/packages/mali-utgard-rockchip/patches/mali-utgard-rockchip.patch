diff --git a/driver/src/devicedrv/mali/common/mali_control_timer.c b/driver/src/devicedrv/mali/common/mali_control_timer.c
index 1296ffe..bfe975f 100644
--- a/driver/src/devicedrv/mali/common/mali_control_timer.c
+++ b/driver/src/devicedrv/mali/common/mali_control_timer.c
@@ -28,7 +28,7 @@ void mali_control_timer_add(u32 timeout)
 	_mali_osk_timer_add(mali_control_timer, _mali_osk_time_mstoticks(timeout));
 }
 
-static void mali_control_timer_callback(void *arg)
+static void mali_control_timer_callback(struct timer_list *t)
 {
 	if (mali_utilization_enabled()) {
 		struct mali_gpu_utilization_data *util_data = NULL;
diff --git a/driver/src/devicedrv/mali/common/mali_group.c b/driver/src/devicedrv/mali/common/mali_group.c
index e9005e1..4451498 100644
--- a/driver/src/devicedrv/mali/common/mali_group.c
+++ b/driver/src/devicedrv/mali/common/mali_group.c
@@ -44,7 +44,7 @@ int mali_max_job_runtime = MALI_MAX_JOB_RUNTIME_DEFAULT;
 static void mali_group_bottom_half_mmu(void *data);
 static void mali_group_bottom_half_gp(void *data);
 static void mali_group_bottom_half_pp(void *data);
-static void mali_group_timeout(void *data);
+static void mali_group_timeout(struct timer_list *t);
 static void mali_group_reset_pp(struct mali_group *group);
 static void mali_group_reset_mmu(struct mali_group *group);
 
@@ -698,7 +698,7 @@ void mali_group_add_group(struct mali_group *parent, struct mali_group *child)
 					      mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
 		trace_gpu_sched_switch(
-			mali_pp_core_description(group->pp_core),
+			mali_pp_core_description(child->pp_core),
 			sched_clock(), mali_pp_job_get_tid(job),
 			0, mali_pp_job_get_id(job));
 #endif
@@ -1761,9 +1761,11 @@ static void mali_group_bottom_half_pp(void *data)
 				      0xFFFFFFFF, 0);
 }
 
-static void mali_group_timeout(void *data)
+static void mali_group_timeout(struct timer_list *t)
 {
-	struct mali_group *group = (struct mali_group *)data;
+	_mali_osk_timer_t *tim = container_of(t, _mali_osk_timer_t, timer);
+	struct mali_group *group = container_of(&tim, struct mali_group, timeout_timer);
+
 	MALI_DEBUG_ASSERT_POINTER(group);
 
 	MALI_DEBUG_PRINT(2, ("Group: timeout handler for %s at %u\n",
diff --git a/driver/src/devicedrv/mali/common/mali_osk_types.h b/driver/src/devicedrv/mali/common/mali_osk_types.h
index 03161cf..c9d0fec 100644
--- a/driver/src/devicedrv/mali/common/mali_osk_types.h
+++ b/driver/src/devicedrv/mali/common/mali_osk_types.h
@@ -50,6 +50,7 @@ typedef unsigned long long u64;
 #include <linux/types.h>
 #endif
 
+#include <linux/timer.h>
 /** @brief Mali Boolean type which uses MALI_TRUE and MALI_FALSE
   */
 typedef unsigned long mali_bool;
@@ -395,7 +396,12 @@ typedef struct _mali_osk_notification_t_struct {
  * by any callers of _mali_osk_timer_del(). Otherwise, a deadlock may occur.
  *
  * @param arg Function-specific data */
-typedef void (*_mali_osk_timer_callback_t)(void *arg);
+typedef void (*_mali_osk_timer_callback_t)(struct timer_list *t);
+
+
+struct _mali_osk_timer_t_struct {
+	struct timer_list timer;
+};
 
 /** @brief Private type for Timer Callback Objects */
 typedef struct _mali_osk_timer_t_struct _mali_osk_timer_t;
diff --git a/driver/src/devicedrv/mali/include/linux/mali/mali_utgard_ioctl.h b/driver/src/devicedrv/mali/include/linux/mali/mali_utgard_ioctl.h
index e2dd993..66bdabb 100644
--- a/driver/src/devicedrv/mali/include/linux/mali/mali_utgard_ioctl.h
+++ b/driver/src/devicedrv/mali/include/linux/mali/mali_utgard_ioctl.h
@@ -51,6 +51,8 @@ extern "C" {
 #define MALI_IOC_WAIT_FOR_NOTIFICATION      _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_WAIT_FOR_NOTIFICATION, _mali_uk_wait_for_notification_s)
 #define MALI_IOC_GET_API_VERSION            _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_GET_API_VERSION, u32)
 #define MALI_IOC_GET_API_VERSION_V2         _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_GET_API_VERSION, _mali_uk_get_api_version_v2_s)
+/* rk_ext. */
+#define MALI_IOC_GET_RK_KO_VERSION          _IOWR(MALI_IOC_CORE_BASE, _MALI_GET_RK_KO_VERSION, _mali_rk_ko_version_s)
 #define MALI_IOC_POST_NOTIFICATION          _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_POST_NOTIFICATION, _mali_uk_post_notification_s)
 #define MALI_IOC_GET_USER_SETTING           _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_GET_USER_SETTING, _mali_uk_get_user_setting_s)
 #define MALI_IOC_GET_USER_SETTINGS          _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_GET_USER_SETTINGS, _mali_uk_get_user_settings_s)
diff --git a/driver/src/devicedrv/mali/include/linux/mali/mali_utgard_uk_types.h b/driver/src/devicedrv/mali/include/linux/mali/mali_utgard_uk_types.h
index afdeadb..9713ab5 100644
--- a/driver/src/devicedrv/mali/include/linux/mali/mali_utgard_uk_types.h
+++ b/driver/src/devicedrv/mali/include/linux/mali/mali_utgard_uk_types.h
@@ -95,6 +95,8 @@ typedef enum {
 	_MALI_UK_SOFT_JOB_SIGNAL,             /**< _mali_ukk_soft_job_signal() */
 	_MALI_UK_PENDING_SUBMIT,             /**< _mali_ukk_pending_submit() */
 
+	_MALI_GET_RK_KO_VERSION,                /* rk_ext */
+
 	/** Memory functions */
 
 	_MALI_UK_ALLOC_MEM                = 0,   /**< _mali_ukk_alloc_mem() */
@@ -708,6 +710,12 @@ typedef struct {
 	int compatible;                 /**< [out] @c 1 when @version is compatible, @c 0 otherwise */
 } _mali_uk_get_api_version_v2_s;
 
+/* rk_ext : rk_ko_ver_t. */
+typedef struct {
+	u64 ctx;                        /**< [in,out] user-kernel context (trashed on output) */
+	_mali_uk_api_version version;   /**< [in,out] API version of user-side interface. */
+} _mali_rk_ko_version_s;
+
 /** @} */ /* end group _mali_uk_getapiversion_s */
 
 /** @defgroup _mali_uk_get_user_settings_s Get user space settings */
diff --git a/driver/src/devicedrv/mali/linux/mali_devfreq.c b/driver/src/devicedrv/mali/linux/mali_devfreq.c
index b28f489..be79eed 100644
--- a/driver/src/devicedrv/mali/linux/mali_devfreq.c
+++ b/driver/src/devicedrv/mali/linux/mali_devfreq.c
@@ -63,13 +63,23 @@ mali_devfreq_target(struct device *dev, unsigned long *target_freq, u32 flags)
 	if (mdev->current_freq == freq) {
 		*target_freq = freq;
 		mali_pm_reset_dvfs_utilisation(mdev);
+#ifdef CONFIG_REGULATOR
+		if (mdev->regulator && mdev->current_voltage != voltage) {
+				err = regulator_set_voltage(mdev->regulator, voltage, INT_MAX);
+				if (err) {
+					MALI_PRINT_ERROR(("Failed to set voltage (%d)\n", err));
+					return err;
+				}
+				mdev->current_voltage = voltage;
+		}
+#endif
 		return 0;
 	}
 
 #ifdef CONFIG_REGULATOR
 	if (mdev->regulator && mdev->current_voltage != voltage
 	    && mdev->current_freq < freq) {
-		err = regulator_set_voltage(mdev->regulator, voltage, voltage);
+		err = regulator_set_voltage(mdev->regulator, voltage, INT_MAX);
 		if (err) {
 			MALI_PRINT_ERROR(("Failed to increase voltage (%d)\n", err));
 			return err;
@@ -86,7 +96,7 @@ mali_devfreq_target(struct device *dev, unsigned long *target_freq, u32 flags)
 #ifdef CONFIG_REGULATOR
 	if (mdev->regulator && mdev->current_voltage != voltage
 	    && mdev->current_freq > freq) {
-		err = regulator_set_voltage(mdev->regulator, voltage, voltage);
+		err = regulator_set_voltage(mdev->regulator, voltage, INT_MAX);
 		if (err) {
 			MALI_PRINT_ERROR(("Failed to decrease voltage (%d)\n", err));
 			return err;
@@ -222,6 +232,10 @@ int mali_devfreq_init(struct mali_device *mdev)
 		return -ENODEV;
 
 	mdev->current_freq = clk_get_rate(mdev->clock);
+#ifdef CONFIG_REGULATOR
+	if (mdev->regulator)
+		mdev->current_voltage = regulator_get_voltage(mdev->regulator);
+#endif
 
 	dp = &mdev->devfreq_profile;
 
@@ -256,6 +270,8 @@ int mali_devfreq_init(struct mali_device *mdev)
 		if (NULL != data.gpu_cooling_ops) {
 			callbacks = data.gpu_cooling_ops;
 			MALI_DEBUG_PRINT(2, ("Mali GPU Thermal: Callback handler installed \n"));
+		} else {
+			MALI_DEBUG_PRINT(2, ("Mali GPU Thermal: No power callbacks\n"));
 		}
 	}
 
diff --git a/driver/src/devicedrv/mali/linux/mali_internal_sync.c b/driver/src/devicedrv/mali/linux/mali_internal_sync.c
index 0478ab5..cc23fc0 100644
--- a/driver/src/devicedrv/mali/linux/mali_internal_sync.c
+++ b/driver/src/devicedrv/mali/linux/mali_internal_sync.c
@@ -121,8 +121,13 @@ static void mali_internal_sync_fence_add_fence(struct mali_internal_sync_fence *
 }
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+static int mali_internal_sync_fence_wake_up_wq(wait_queue_entry_t *curr, unsigned mode,
+		int wake_flags, void *key)
+#else
 static int mali_internal_sync_fence_wake_up_wq(wait_queue_t *curr, unsigned mode,
 		int wake_flags, void *key)
+#endif
 {
 	struct mali_internal_sync_fence_waiter *wait;
 	MALI_IGNORE(mode);
@@ -130,7 +135,11 @@ static int mali_internal_sync_fence_wake_up_wq(wait_queue_t *curr, unsigned mode
 	MALI_IGNORE(key);
 
 	wait = container_of(curr, struct mali_internal_sync_fence_waiter, work);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+	list_del_init(&wait->work.entry);
+#else
 	list_del_init(&wait->work.task_list);
+#endif
 
 	wait->callback(wait->work.private, wait);
 	return 1;
@@ -508,7 +517,11 @@ void mali_internal_sync_fence_waiter_init(struct mali_internal_sync_fence_waiter
 	MALI_DEBUG_ASSERT_POINTER(waiter);
 	MALI_DEBUG_ASSERT_POINTER(callback);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+	INIT_LIST_HEAD(&waiter->work.entry);
+#else
 	INIT_LIST_HEAD(&waiter->work.task_list);
+#endif
 	waiter->callback = callback;
 }
 
@@ -536,7 +549,11 @@ int mali_internal_sync_fence_wait_async(struct mali_internal_sync_fence *sync_fe
 	err = atomic_read(&sync_fence->status);
 
 	if (0 < err)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+		__add_wait_queue_entry_tail(&sync_fence->wq, &waiter->work);
+#else
 		__add_wait_queue_tail(&sync_fence->wq, &waiter->work);
+#endif
 	spin_unlock_irqrestore(&sync_fence->wq.lock, flags);
 
 	if (0 > err)
@@ -571,7 +588,11 @@ int mali_internal_sync_fence_wait_async(struct mali_internal_sync_fence *sync_fe
 	err =  sync_fence->fence->ops->signaled(sync_fence->fence);
 
 	if (0 == err)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+		__add_wait_queue_entry_tail(&sync_fence->wq, &waiter->work);
+#else
 		__add_wait_queue_tail(&sync_fence->wq, &waiter->work);
+#endif
 	spin_unlock_irqrestore(&sync_fence->wq.lock, flags);
 
 	return err;
@@ -588,8 +609,13 @@ int mali_internal_sync_fence_cancel_async(struct mali_internal_sync_fence *sync_
 	MALI_DEBUG_ASSERT_POINTER(waiter);
 
 	spin_lock_irqsave(&sync_fence->wq.lock, flags);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+	if (!list_empty(&waiter->work.entry))
+		list_del_init(&waiter->work.entry);
+#else
 	if (!list_empty(&waiter->work.task_list))
 		list_del_init(&waiter->work.task_list);
+#endif
 	else
 		ret = -ENOENT;
 	spin_unlock_irqrestore(&sync_fence->wq.lock, flags);
@@ -689,7 +715,7 @@ static bool mali_internal_fence_signaled(struct fence *fence)
 
 	ret = parent->ops->has_signaled(sync_pt);
 	if (0 > ret)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 68)
 		fence->error = ret;
 #else
 		fence->status = ret;
diff --git a/driver/src/devicedrv/mali/linux/mali_internal_sync.h b/driver/src/devicedrv/mali/linux/mali_internal_sync.h
index a5655c7..70f29f9 100644
--- a/driver/src/devicedrv/mali/linux/mali_internal_sync.h
+++ b/driver/src/devicedrv/mali/linux/mali_internal_sync.h
@@ -112,7 +112,11 @@ typedef void (*mali_internal_sync_callback_t)(struct mali_internal_sync_fence *s
 		struct mali_internal_sync_fence_waiter *waiter);
 
 struct mali_internal_sync_fence_waiter {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+	wait_queue_entry_t work;
+#else
 	wait_queue_t work;
+#endif
 	mali_internal_sync_callback_t callback;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
diff --git a/driver/src/devicedrv/mali/linux/mali_kernel_linux.c b/driver/src/devicedrv/mali/linux/mali_kernel_linux.c
index d7893a3..2cdf992 100644
--- a/driver/src/devicedrv/mali/linux/mali_kernel_linux.c
+++ b/driver/src/devicedrv/mali/linux/mali_kernel_linux.c
@@ -554,16 +554,16 @@ static int mali_probe(struct platform_device *pdev)
 		MALI_DEBUG_PRINT(3, ("OPP table not found\n"));
 #endif
 
-	/* Need to name the gpu clock "clk_mali" in the device tree */
-	mdev->clock = clk_get(mdev->dev, "clk_mali");
+	/* Need to name the gpu clock "core" in the device tree */
+	mdev->clock = clk_get(mdev->dev, "core");
 	if (IS_ERR_OR_NULL(mdev->clock)) {
 		MALI_DEBUG_PRINT(2, ("Continuing without Mali clock control\n"));
 		mdev->clock = NULL;
 		/* Allow probe to continue without clock. */
 	} else {
-		err = clk_prepare_enable(mdev->clock);
+		err = clk_prepare(mdev->clock);
 		if (err) {
-			MALI_PRINT_ERROR(("Failed to prepare and enable clock (%d)\n", err));
+			MALI_PRINT_ERROR(("Failed to prepare clock (%d)\n", err));
 			goto clock_prepare_failed;
 		}
 	}
@@ -613,7 +613,7 @@ static int mali_probe(struct platform_device *pdev)
 devfreq_init_failed:
 	mali_pm_metrics_term(mdev);
 pm_metrics_init_failed:
-	clk_disable_unprepare(mdev->clock);
+	clk_unprepare(mdev->clock);
 clock_prepare_failed:
 	clk_put(mdev->clock);
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)) && defined(CONFIG_OF) \
@@ -653,7 +653,7 @@ static int mali_remove(struct platform_device *pdev)
 	mali_pm_metrics_term(mdev);
 
 	if (mdev->clock) {
-		clk_disable_unprepare(mdev->clock);
+		clk_unprepare(mdev->clock);
 		clk_put(mdev->clock);
 		mdev->clock = NULL;
 	}
@@ -937,6 +937,10 @@ static int mali_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
 		err = post_notification_wrapper(session_data, (_mali_uk_post_notification_s __user *)arg);
 		break;
 
+    case MALI_IOC_GET_RK_KO_VERSION:
+		err = get_rk_ko_version_wrapper(session_data, (_mali_rk_ko_version_s __user *)arg);
+		break;
+
 	case MALI_IOC_GET_USER_SETTINGS:
 		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_get_user_settings_s), sizeof(u64)));
 		err = get_user_settings_wrapper(session_data, (_mali_uk_get_user_settings_s __user *)arg);
diff --git a/driver/src/devicedrv/mali/linux/mali_memory_os_alloc.c b/driver/src/devicedrv/mali/linux/mali_memory_os_alloc.c
index 5fe1270..92c245a 100644
--- a/driver/src/devicedrv/mali/linux/mali_memory_os_alloc.c
+++ b/driver/src/devicedrv/mali/linux/mali_memory_os_alloc.c
@@ -202,7 +202,13 @@ int mali_mem_os_alloc_pages(mali_mem_os_mem *os_mem, u32 size)
 	/* Allocate new pages, if needed. */
 	for (i = 0; i < remaining; i++) {
 		dma_addr_t dma_addr;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0)
+		gfp_t flags = __GFP_ZERO | __GFP_RETRY_MAYFAIL | __GFP_NOWARN;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+		gfp_t flags = __GFP_ZERO | __GFP_RETRY_MAYFAIL | __GFP_NOWARN | __GFP_COLD;
+#else
 		gfp_t flags = __GFP_ZERO | __GFP_REPEAT | __GFP_NOWARN | __GFP_COLD;
+#endif
 		int err;
 
 #if defined(CONFIG_ARM) && !defined(CONFIG_ARM_LPAE)
diff --git a/driver/src/devicedrv/mali/linux/mali_memory_secure.c b/driver/src/devicedrv/mali/linux/mali_memory_secure.c
index 2836b1b..4f55fa5 100644
--- a/driver/src/devicedrv/mali/linux/mali_memory_secure.c
+++ b/driver/src/devicedrv/mali/linux/mali_memory_secure.c
@@ -13,7 +13,11 @@
 #include "mali_memory_secure.h"
 #include "mali_osk.h"
 #include <linux/mutex.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 16, 0)
+#include <linux/dma-direct.h>
+#else
 #include <linux/dma-mapping.h>
+#endif
 #include <linux/dma-buf.h>
 
 _mali_osk_errcode_t mali_mem_secure_attach_dma_buf(mali_mem_secure *secure_mem, u32 size, int mem_fd)
diff --git a/driver/src/devicedrv/mali/linux/mali_memory_swap_alloc.c b/driver/src/devicedrv/mali/linux/mali_memory_swap_alloc.c
index a54faca..012cfe1 100644
--- a/driver/src/devicedrv/mali/linux/mali_memory_swap_alloc.c
+++ b/driver/src/devicedrv/mali/linux/mali_memory_swap_alloc.c
@@ -248,7 +248,11 @@ static void mali_mem_swap_swapped_bkend_pool_shrink(_mali_mem_swap_pool_shrink_t
 	}
 
 	/* Get system free pages number. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	system_free_size = global_zone_page_state(NR_FREE_PAGES) * PAGE_SIZE;
+#else
 	system_free_size = global_page_state(NR_FREE_PAGES) * PAGE_SIZE;
+#endif
 	last_gpu_utilization = _mali_ukk_utilization_gp_pp();
 
 	if ((last_gpu_utilization < gpu_utilization_threshold_value)
@@ -576,7 +580,11 @@ int mali_mem_swap_alloc_pages(mali_mem_swap *swap_mem, u32 size, u32 *bkend_idx)
 		list_add_tail(&m_page->list, &swap_mem->pages);
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	system_free_size = global_zone_page_state(NR_FREE_PAGES) * PAGE_SIZE;
+#else
 	system_free_size = global_page_state(NR_FREE_PAGES) * PAGE_SIZE;
+#endif
 
 	if ((system_free_size < mali_mem_swap_out_threshold_value)
 	    && (mem_backend_swapped_pool_size > (mali_mem_swap_out_threshold_value >> 2))
diff --git a/driver/src/devicedrv/mali/linux/mali_osk_mali.c b/driver/src/devicedrv/mali/linux/mali_osk_mali.c
index 01ccac1..94fc5fd 100644
--- a/driver/src/devicedrv/mali/linux/mali_osk_mali.c
+++ b/driver/src/devicedrv/mali/linux/mali_osk_mali.c
@@ -72,26 +72,26 @@ int (*mali_gpu_reset_and_secure_mode_disable)(void) = NULL;
 #define MALI_OSK_RESOURCE_DMA_LOCATION 26
 
 static _mali_osk_resource_t mali_osk_resource_bank[MALI_OSK_MAX_RESOURCE_NUMBER] = {
-	{.description = "Mali_GP", .base = MALI_OFFSET_GP, .irq_name = "IRQGP",},
-	{.description = "Mali_GP_MMU", .base = MALI_OFFSET_GP_MMU, .irq_name = "IRQGPMMU",},
-	{.description = "Mali_PP0", .base = MALI_OFFSET_PP0, .irq_name = "IRQPP0",},
-	{.description = "Mali_PP0_MMU", .base = MALI_OFFSET_PP0_MMU, .irq_name = "IRQPPMMU0",},
-	{.description = "Mali_PP1", .base = MALI_OFFSET_PP1, .irq_name = "IRQPP1",},
-	{.description = "Mali_PP1_MMU", .base = MALI_OFFSET_PP1_MMU, .irq_name = "IRQPPMMU1",},
-	{.description = "Mali_PP2", .base = MALI_OFFSET_PP2, .irq_name = "IRQPP2",},
-	{.description = "Mali_PP2_MMU", .base = MALI_OFFSET_PP2_MMU, .irq_name = "IRQPPMMU2",},
-	{.description = "Mali_PP3", .base = MALI_OFFSET_PP3, .irq_name = "IRQPP3",},
-	{.description = "Mali_PP3_MMU", .base = MALI_OFFSET_PP3_MMU, .irq_name = "IRQPPMMU3",},
-	{.description = "Mali_PP4", .base = MALI_OFFSET_PP4, .irq_name = "IRQPP4",},
-	{.description = "Mali_PP4_MMU", .base = MALI_OFFSET_PP4_MMU, .irq_name = "IRQPPMMU4",},
-	{.description = "Mali_PP5", .base = MALI_OFFSET_PP5, .irq_name = "IRQPP5",},
-	{.description = "Mali_PP5_MMU", .base = MALI_OFFSET_PP5_MMU, .irq_name = "IRQPPMMU5",},
-	{.description = "Mali_PP6", .base = MALI_OFFSET_PP6, .irq_name = "IRQPP6",},
-	{.description = "Mali_PP6_MMU", .base = MALI_OFFSET_PP6_MMU, .irq_name = "IRQPPMMU6",},
-	{.description = "Mali_PP7", .base = MALI_OFFSET_PP7, .irq_name = "IRQPP7",},
-	{.description = "Mali_PP7_MMU", .base = MALI_OFFSET_PP7_MMU, .irq_name = "IRQPPMMU",},
-	{.description = "Mali_PP_Broadcast", .base = MALI_OFFSET_PP_BCAST, .irq_name = "IRQPP",},
-	{.description = "Mali_PMU", .base = MALI_OFFSET_PMU, .irq_name = "IRQPMU",},
+	{.description = "Mali_GP", .base = MALI_OFFSET_GP, .irq_name = "gp",},
+	{.description = "Mali_GP_MMU", .base = MALI_OFFSET_GP_MMU, .irq_name = "gpmmu",},
+	{.description = "Mali_PP0", .base = MALI_OFFSET_PP0, .irq_name = "pp0",},
+	{.description = "Mali_PP0_MMU", .base = MALI_OFFSET_PP0_MMU, .irq_name = "ppmmu0",},
+	{.description = "Mali_PP1", .base = MALI_OFFSET_PP1, .irq_name = "pp1",},
+	{.description = "Mali_PP1_MMU", .base = MALI_OFFSET_PP1_MMU, .irq_name = "ppmmu1",},
+	{.description = "Mali_PP2", .base = MALI_OFFSET_PP2, .irq_name = "pp2",},
+	{.description = "Mali_PP2_MMU", .base = MALI_OFFSET_PP2_MMU, .irq_name = "ppmmu2",},
+	{.description = "Mali_PP3", .base = MALI_OFFSET_PP3, .irq_name = "pp3",},
+	{.description = "Mali_PP3_MMU", .base = MALI_OFFSET_PP3_MMU, .irq_name = "ppmmu3",},
+	{.description = "Mali_PP4", .base = MALI_OFFSET_PP4, .irq_name = "pp4",},
+	{.description = "Mali_PP4_MMU", .base = MALI_OFFSET_PP4_MMU, .irq_name = "ppmmu4",},
+	{.description = "Mali_PP5", .base = MALI_OFFSET_PP5, .irq_name = "pp5",},
+	{.description = "Mali_PP5_MMU", .base = MALI_OFFSET_PP5_MMU, .irq_name = "ppmmu5",},
+	{.description = "Mali_PP6", .base = MALI_OFFSET_PP6, .irq_name = "pp6",},
+	{.description = "Mali_PP6_MMU", .base = MALI_OFFSET_PP6_MMU, .irq_name = "ppmmu6",},
+	{.description = "Mali_PP7", .base = MALI_OFFSET_PP7, .irq_name = "pp7",},
+	{.description = "Mali_PP7_MMU", .base = MALI_OFFSET_PP7_MMU, .irq_name = "ppmmu7",},
+	{.description = "Mali_PP_Broadcast", .base = MALI_OFFSET_PP_BCAST, .irq_name = "pp",},
+	{.description = "Mali_PMU", .base = MALI_OFFSET_PMU, .irq_name = "pmu",},
 	{.description = "Mali_L2", .base = MALI_OFFSET_L2_RESOURCE0,},
 	{.description = "Mali_L2", .base = MALI_OFFSET_L2_RESOURCE1,},
 	{.description = "Mali_L2", .base = MALI_OFFSET_L2_RESOURCE2,},
@@ -101,13 +101,13 @@ static _mali_osk_resource_t mali_osk_resource_bank[MALI_OSK_MAX_RESOURCE_NUMBER]
 	{.description = "Mali_DMA", .base = MALI_OFFSET_DMA,},
 };
 
-static int _mali_osk_get_compatible_name(const char **out_string)
+static int _mali_osk_device_is_compatible(const char *name)
 {
 	struct device_node *node = mali_platform_device->dev.of_node;
 
 	MALI_DEBUG_ASSERT(NULL != node);
 
-	return of_property_read_string(node, "compatible", out_string);
+	return of_device_is_compatible(node, name);
 }
 
 _mali_osk_errcode_t _mali_osk_resource_initialize(void)
@@ -115,17 +115,14 @@ _mali_osk_errcode_t _mali_osk_resource_initialize(void)
 	mali_bool mali_is_450 = MALI_FALSE, mali_is_470 = MALI_FALSE;
 	int i, pp_core_num = 0, l2_core_num = 0;
 	struct resource *res;
-	const char *compatible_name = NULL;
-
-	if (0 == _mali_osk_get_compatible_name(&compatible_name)) {
-		if (0 == strncmp(compatible_name, "arm,mali-450", strlen("arm,mali-450"))) {
-			mali_is_450 = MALI_TRUE;
-			MALI_DEBUG_PRINT(2, ("mali-450 device tree detected."));
-		} else if (0 == strncmp(compatible_name, "arm,mali-470", strlen("arm,mali-470"))) {
-			mali_is_470 = MALI_TRUE;
-			MALI_DEBUG_PRINT(2, ("mali-470 device tree detected."));
-		}
-	}
+
+    if (_mali_osk_device_is_compatible("arm,mali-450")) {
+        mali_is_450 = MALI_TRUE;
+        MALI_DEBUG_PRINT(2, ("mali-450 device tree detected."));
+    } else if (_mali_osk_device_is_compatible("arm,mali-470")) {
+        mali_is_470 = MALI_TRUE;
+        MALI_DEBUG_PRINT(2, ("mali-470 device tree detected."));
+    }
 
 	for (i = 0; i < MALI_OSK_RESOURCE_WITH_IRQ_NUMBER; i++) {
 		res = platform_get_resource_byname(mali_platform_device, IORESOURCE_IRQ, mali_osk_resource_bank[i].irq_name);
diff --git a/driver/src/devicedrv/mali/linux/mali_osk_notification.c b/driver/src/devicedrv/mali/linux/mali_osk_notification.c
index b22fe68..dac0327 100644
--- a/driver/src/devicedrv/mali/linux/mali_osk_notification.c
+++ b/driver/src/devicedrv/mali/linux/mali_osk_notification.c
@@ -57,7 +57,11 @@ _mali_osk_notification_t *_mali_osk_notification_create(u32 type, u32 size)
 	_mali_osk_notification_wrapper_t *notification;
 
 	notification = (_mali_osk_notification_wrapper_t *)kmalloc(sizeof(_mali_osk_notification_wrapper_t) + size,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+			GFP_KERNEL | __GFP_HIGH | __GFP_RETRY_MAYFAIL);
+#else
 			GFP_KERNEL | __GFP_HIGH | __GFP_REPEAT);
+#endif
 	if (NULL == notification) {
 		MALI_DEBUG_PRINT(1, ("Failed to create a notification object\n"));
 		return NULL;
diff --git a/driver/src/devicedrv/mali/linux/mali_osk_timers.c b/driver/src/devicedrv/mali/linux/mali_osk_timers.c
index e5d7238..701051a 100644
--- a/driver/src/devicedrv/mali/linux/mali_osk_timers.c
+++ b/driver/src/devicedrv/mali/linux/mali_osk_timers.c
@@ -18,16 +18,25 @@
 #include "mali_osk.h"
 #include "mali_kernel_common.h"
 
-struct _mali_osk_timer_t_struct {
-	struct timer_list timer;
-};
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+
+#define TIMER_DATA_TYPE		unsigned long
+#define TIMER_FUNC_TYPE		void (*)(TIMER_DATA_TYPE)
+
+static inline void timer_setup(struct timer_list *timer,
+			       void (*callback)(struct timer_list *),
+			       unsigned int flags)
+{
+	__setup_timer(timer, (TIMER_FUNC_TYPE)callback,
+		      (TIMER_DATA_TYPE)timer, flags);
+}
+#endif
 
 typedef void (*timer_timeout_function_t)(unsigned long);
 
 _mali_osk_timer_t *_mali_osk_timer_init(void)
 {
 	_mali_osk_timer_t *t = (_mali_osk_timer_t *)kmalloc(sizeof(_mali_osk_timer_t), GFP_KERNEL);
-	if (NULL != t) init_timer(&t->timer);
 	return t;
 }
 
@@ -65,8 +74,7 @@ mali_bool _mali_osk_timer_pending(_mali_osk_timer_t *tim)
 void _mali_osk_timer_setcallback(_mali_osk_timer_t *tim, _mali_osk_timer_callback_t callback, void *data)
 {
 	MALI_DEBUG_ASSERT_POINTER(tim);
-	tim->timer.data = (unsigned long)data;
-	tim->timer.function = (timer_timeout_function_t)callback;
+	timer_setup(&tim->timer, callback, 0);
 }
 
 void _mali_osk_timer_term(_mali_osk_timer_t *tim)
diff --git a/driver/src/devicedrv/mali/linux/mali_ukk_core.c b/driver/src/devicedrv/mali/linux/mali_ukk_core.c
index 3a9a589..9e9ac4d 100644
--- a/driver/src/devicedrv/mali/linux/mali_ukk_core.c
+++ b/driver/src/devicedrv/mali/linux/mali_ukk_core.c
@@ -60,6 +60,17 @@ int get_api_version_v2_wrapper(struct mali_session_data *session_data, _mali_uk_
 	return 0;
 }
 
+#define RK_KO_VER (5)
+int get_rk_ko_version_wrapper(struct mali_session_data *session_data, _mali_rk_ko_version_s __user *uargs)
+{
+	_mali_rk_ko_version_s kargs;
+	MALI_CHECK_NON_NULL(uargs, -EINVAL);
+	kargs.ctx = (uintptr_t)session_data;
+	kargs.version = RK_KO_VER;
+	if (0 != put_user(kargs.version, &uargs->version)) return -EFAULT;
+	return 0;
+}
+
 int wait_for_notification_wrapper(struct mali_session_data *session_data, _mali_uk_wait_for_notification_s __user *uargs)
 {
 	_mali_uk_wait_for_notification_s kargs;
diff --git a/driver/src/devicedrv/mali/linux/mali_ukk_wrappers.h b/driver/src/devicedrv/mali/linux/mali_ukk_wrappers.h
index 893c912..d1475b4 100644
--- a/driver/src/devicedrv/mali/linux/mali_ukk_wrappers.h
+++ b/driver/src/devicedrv/mali/linux/mali_ukk_wrappers.h
@@ -31,6 +31,8 @@ int post_notification_wrapper(struct mali_session_data *session_data, _mali_uk_p
 int request_high_priority_wrapper(struct mali_session_data *session_data, _mali_uk_request_high_priority_s __user *uargs);
 int pending_submit_wrapper(struct mali_session_data *session_data, _mali_uk_pending_submit_s __user *uargs);
 
+int get_rk_ko_version_wrapper(struct mali_session_data *session_data, _mali_rk_ko_version_s __user *uargs);
+
 int mem_alloc_wrapper(struct mali_session_data *session_data, _mali_uk_alloc_mem_s __user *uargs);
 int mem_free_wrapper(struct mali_session_data *session_data, _mali_uk_free_mem_s __user *uargs);
 int mem_bind_wrapper(struct mali_session_data *session_data, _mali_uk_bind_mem_s __user *uargs);
diff --git a/driver/src/devicedrv/mali/platform/arm/arm.c b/driver/src/devicedrv/mali/platform/arm/arm.c
index 4e09aca..f1150a3 100644
--- a/driver/src/devicedrv/mali/platform/arm/arm.c
+++ b/driver/src/devicedrv/mali/platform/arm/arm.c
@@ -183,7 +183,8 @@ static struct resource mali_gpu_resources_m400_mp2[] = {
 static struct thermal_zone_device *gpu_tz;
 
 /* Calculate gpu static power example for reference */
-static unsigned long arm_model_static_power(unsigned long voltage)
+static unsigned long arm_model_static_power(struct devfreq *devfreq,
+					    unsigned long voltage)
 {
 	int temperature, temp;
 	int temp_squared, temp_cubed, temp_scaling_factor;
@@ -223,7 +224,8 @@ static unsigned long arm_model_static_power(unsigned long voltage)
 }
 
 /* Calculate gpu dynamic power example for reference */
-static unsigned long arm_model_dynamic_power(unsigned long freq,
+static unsigned long arm_model_dynamic_power(struct devfreq *devfreq,
+		unsigned long freq,
 		unsigned long voltage)
 {
 	/* The inputs: freq (f) is in Hz, and voltage (v) in mV.
diff --git a/driver/src/devicedrv/mali/platform/rk/rk.c b/driver/src/devicedrv/mali/platform/rk/rk.c
new file mode 100644
index 0000000..1ed8a44
--- /dev/null
+++ b/driver/src/devicedrv/mali/platform/rk/rk.c
@@ -0,0 +1,648 @@
+/*
+ * (C) COPYRIGHT RockChip Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ */
+
+/**
+ * @file rk.c
+ * implementation of platform_specific_code on rk platforms, such as rk3328h.
+ *
+ * mali_device_driver(MDD) includes 2 parts :
+ *	.DP : platform_dependent_part :
+ *		located in <mdd_src_dir>/mali/platform/<platform_name>/
+ *	.DP : common_part :
+ *		common part implemented by ARM.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/pm.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#ifdef CONFIG_PM
+#include <linux/pm_runtime.h>
+#endif
+#include <linux/workqueue.h>
+#include <linux/dma-mapping.h>
+#include <linux/pm_runtime.h>
+#include <linux/delay.h>
+
+#include <linux/mali/mali_utgard.h>
+#include "mali_kernel_common.h"
+#include "../../common/mali_osk_mali.h"
+
+/*---------------------------------------------------------------------------*/
+
+#define DEFAULT_UTILISATION_PERIOD_IN_MS (100)
+
+/*
+ * rk_platform_context_of_mali_device.
+ */
+struct rk_context {
+	/* mali device. */
+	struct device *dev;
+	/* is the GPU powered on?  */
+	bool is_powered;
+	/* debug only, the period in ms to count gpu_utilisation. */
+	unsigned int utilisation_period;
+};
+
+struct rk_context *s_rk_context;
+
+/*---------------------------------------------------------------------------*/
+
+#ifdef CONFIG_MALI_DEVFREQ
+static ssize_t utilisation_period_show(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	struct rk_context *platform = s_rk_context;
+	ssize_t ret = 0;
+
+	ret += snprintf(buf, PAGE_SIZE, "%u\n", platform->utilisation_period);
+
+	return ret;
+}
+
+static ssize_t utilisation_period_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf,
+					size_t count)
+{
+	struct rk_context *platform = s_rk_context;
+	int ret = 0;
+
+	ret = kstrtouint(buf, 0, &platform->utilisation_period);
+	if (ret) {
+		//E("invalid input period : %s.", buf);
+		return ret;
+	}
+	//D("set utilisation_period to '%d'.", platform->utilisation_period);
+
+	return count;
+}
+
+static ssize_t utilisation_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct rk_context *platform = s_rk_context;
+	struct mali_device *mdev = dev_get_drvdata(dev);
+	ssize_t ret = 0;
+	unsigned long period_in_us = platform->utilisation_period * 1000;
+	unsigned long total_time;
+	unsigned long busy_time;
+	unsigned long utilisation;
+
+	mali_pm_reset_dvfs_utilisation(mdev);
+	usleep_range(period_in_us, period_in_us + 100);
+	mali_pm_get_dvfs_utilisation(mdev, &total_time, &busy_time);
+
+	/* 'devfreq_dev_profile' instance registered to devfreq
+	 * also uses mali_pm_reset_dvfs_utilisation()
+	 * and mali_pm_get_dvfs_utilisation().
+	 * So, it's better to disable GPU DVFS before reading this node.
+	 */
+	//D("total_time : %lu, busy_time : %lu.", total_time, busy_time);
+
+	utilisation = busy_time / (total_time / 100);
+	ret += snprintf(buf, PAGE_SIZE, "%lu\n", utilisation);
+
+	return ret;
+}
+
+static DEVICE_ATTR_RW(utilisation_period);
+static DEVICE_ATTR_RO(utilisation);
+#endif
+
+static int rk_context_create_sysfs_files(struct device *dev)
+{
+#ifdef CONFIG_MALI_DEVFREQ
+	int ret;
+
+	ret = device_create_file(dev, &dev_attr_utilisation_period);
+	if (ret) {
+		//E("fail to create sysfs file 'utilisation_period'.");
+		goto out;
+	}
+
+	ret = device_create_file(dev, &dev_attr_utilisation);
+	if (ret) {
+		//E("fail to create sysfs file 'utilisation'.");
+		goto remove_utilisation_period;
+	}
+
+	return 0;
+
+remove_utilisation_period:
+	device_remove_file(dev, &dev_attr_utilisation_period);
+out:
+	return ret;
+#else
+	return 0;
+#endif
+}
+
+static void rk_context_remove_sysfs_files(struct device *dev)
+{
+#ifdef CONFIG_MALI_DEVFREQ
+	device_remove_file(dev, &dev_attr_utilisation_period);
+	device_remove_file(dev, &dev_attr_utilisation);
+#endif
+}
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * Init rk_platform_context of mali_device.
+ */
+static int rk_context_init(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *dev = &pdev->dev;
+	struct rk_context *platform; /* platform_context */
+
+	platform = kzalloc(sizeof(*platform), GFP_KERNEL);
+	if (!platform) {
+		//E("no mem.");
+		return _MALI_OSK_ERR_NOMEM;
+	}
+
+	platform->dev = dev;
+	platform->is_powered = false;
+
+	platform->utilisation_period = DEFAULT_UTILISATION_PERIOD_IN_MS;
+
+	ret = rk_context_create_sysfs_files(dev);
+	if (ret) {
+		//E("fail to create sysfs files, ret = %d", ret);
+		goto EXIT;
+	}
+
+	s_rk_context = platform;
+
+	pm_runtime_set_autosuspend_delay(dev, 1000);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_enable(dev);
+
+EXIT:
+	return ret;
+}
+
+static void rk_context_deinit(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rk_context *platform = s_rk_context;
+
+	pm_runtime_disable(dev);
+
+	s_rk_context = NULL;
+
+	rk_context_remove_sysfs_files(dev);
+
+	if (platform) {
+		platform->is_powered = false;
+		platform->dev = NULL;
+		kfree(platform);
+	}
+}
+
+/*---------------------------------------------------------------------------*/
+/* for devfreq cooling. */
+
+#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_DEVFREQ_THERMAL)
+
+#define FALLBACK_STATIC_TEMPERATURE 55000
+
+static u32 dynamic_coefficient;
+static u32 static_coefficient;
+static s32 ts[4];
+static struct thermal_zone_device *gpu_tz;
+
+static int power_model_simple_init(struct platform_device *pdev)
+{
+	struct device_node *power_model_node;
+	const char *tz_name;
+	u32 static_power, dynamic_power;
+	u32 voltage, voltage_squared, voltage_cubed, frequency;
+
+	power_model_node = of_get_child_by_name(pdev->dev.of_node,
+			"power_model");
+	if (!power_model_node) {
+		dev_err(&pdev->dev, "could not find power_model node\n");
+		return -ENODEV;
+	}
+	if (!of_device_is_compatible(power_model_node,
+			"arm,mali-simple-power-model")) {
+		dev_err(&pdev->dev, "power_model incompatible with simple power model\n");
+		return -ENODEV;
+	}
+
+	if (of_property_read_string(power_model_node, "thermal-zone",
+			&tz_name)) {
+		dev_err(&pdev->dev, "ts in power_model not available\n");
+		return -EINVAL;
+	}
+
+	gpu_tz = thermal_zone_get_zone_by_name(tz_name);
+	if (IS_ERR(gpu_tz)) {
+		pr_warn_ratelimited("Error getting gpu thermal zone '%s'(%ld), not yet ready?\n",
+				tz_name,
+				PTR_ERR(gpu_tz));
+		gpu_tz = NULL;
+	}
+
+	if (of_property_read_u32(power_model_node, "static-power",
+			&static_power)) {
+		dev_err(&pdev->dev, "static-power in power_model not available\n");
+		return -EINVAL;
+	}
+	if (of_property_read_u32(power_model_node, "dynamic-power",
+			&dynamic_power)) {
+		dev_err(&pdev->dev, "dynamic-power in power_model not available\n");
+		return -EINVAL;
+	}
+	if (of_property_read_u32(power_model_node, "voltage",
+			&voltage)) {
+		dev_err(&pdev->dev, "voltage in power_model not available\n");
+		return -EINVAL;
+	}
+	if (of_property_read_u32(power_model_node, "frequency",
+			&frequency)) {
+		dev_err(&pdev->dev, "frequency in power_model not available\n");
+		return -EINVAL;
+	}
+	voltage_squared = (voltage * voltage) / 1000;
+	voltage_cubed = voltage * voltage * voltage;
+	static_coefficient = (static_power << 20) / (voltage_cubed >> 10);
+	dynamic_coefficient = (((dynamic_power * 1000) / voltage_squared)
+			* 1000) / frequency;
+
+	if (of_property_read_u32_array(power_model_node, "ts", (u32 *)ts, 4)) {
+		dev_err(&pdev->dev, "ts in power_model not available\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Calculate gpu static power example for reference */
+static unsigned long rk_model_static_power(struct devfreq *devfreq,
+					   unsigned long voltage)
+{
+	int temperature, temp;
+	int temp_squared, temp_cubed, temp_scaling_factor;
+	const unsigned long voltage_cubed = (voltage * voltage * voltage) >> 10;
+	unsigned long static_power;
+
+	if (gpu_tz) {
+		int ret;
+
+		ret = gpu_tz->ops->get_temp(gpu_tz, &temperature);
+		if (ret) {
+			MALI_DEBUG_PRINT(2, ("Error reading temperature for gpu thermal zone: %d\n", ret));
+			temperature = FALLBACK_STATIC_TEMPERATURE;
+		}
+	} else {
+		temperature = FALLBACK_STATIC_TEMPERATURE;
+	}
+
+	/* Calculate the temperature scaling factor. To be applied to the
+	 * voltage scaled power.
+	 */
+	temp = temperature / 1000;
+	temp_squared = temp * temp;
+	temp_cubed = temp_squared * temp;
+	temp_scaling_factor =
+			(ts[3] * temp_cubed)
+			+ (ts[2] * temp_squared)
+			+ (ts[1] * temp)
+			+ ts[0];
+
+	static_power = (((static_coefficient * voltage_cubed) >> 20)
+			* temp_scaling_factor)
+		       / 1000000;
+
+	return static_power;
+}
+
+/* Calculate gpu dynamic power example for reference */
+static unsigned long rk_model_dynamic_power(struct devfreq *devfreq,
+					    unsigned long freq,
+					    unsigned long voltage)
+{
+	/* The inputs: freq (f) is in Hz, and voltage (v) in mV.
+	 * The coefficient (c) is in mW/(MHz mV mV).
+	 *
+	 * This function calculates the dynamic power after this formula:
+	 * Pdyn (mW) = c (mW/(MHz*mV*mV)) * v (mV) * v (mV) * f (MHz)
+	 */
+	const unsigned long v2 = (voltage * voltage) / 1000; /* m*(V*V) */
+	const unsigned long f_mhz = freq / 1000000; /* MHz */
+	unsigned long dynamic_power;
+
+	dynamic_power = (dynamic_coefficient * v2 * f_mhz) / 1000000; /* mW */
+
+	return dynamic_power;
+}
+
+struct devfreq_cooling_power rk_cooling_ops = {
+	.get_static_power = rk_model_static_power,
+	.get_dynamic_power = rk_model_dynamic_power,
+};
+#endif
+
+/*---------------------------------------------------------------------------*/
+
+#ifdef CONFIG_PM
+
+static int rk_platform_enable_clk_gpu(struct device *dev)
+{
+	int ret = 0;
+#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_HAVE_CLK)
+	struct mali_device *mdev = dev_get_drvdata(dev);
+
+	if (mdev->clock)
+		ret = clk_enable(mdev->clock);
+#endif
+	return ret;
+}
+
+static void rk_platform_disable_clk_gpu(struct device *dev)
+{
+#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_HAVE_CLK)
+	struct mali_device *mdev = dev_get_drvdata(dev);
+
+	if (mdev->clock)
+		clk_disable(mdev->clock);
+#endif
+}
+
+static int rk_platform_enable_gpu_regulator(struct device *dev)
+{
+	int ret = 0;
+#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_REGULATOR)
+	struct mali_device *mdev = dev_get_drvdata(dev);
+
+	if (mdev->regulator)
+		ret = regulator_enable(mdev->regulator);
+#endif
+	return ret;
+}
+
+static void rk_platform_disable_gpu_regulator(struct device *dev)
+{
+#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_REGULATOR)
+	struct mali_device *mdev = dev_get_drvdata(dev);
+
+	if (mdev->regulator)
+		regulator_disable(mdev->regulator);
+#endif
+}
+
+static int rk_platform_power_on_gpu(struct device *dev)
+{
+	int ret = 0;
+
+	ret = rk_platform_enable_clk_gpu(dev);
+	if (ret) {
+		//E("fail to enable clk_gpu, ret : %d.", ret);
+		goto fail_to_enable_clk;
+	}
+
+	ret = rk_platform_enable_gpu_regulator(dev);
+	if (ret) {
+		//E("fail to enable vdd_gpu, ret : %d.", ret);
+		goto fail_to_enable_regulator;
+	}
+
+	return 0;
+
+fail_to_enable_regulator:
+	rk_platform_disable_clk_gpu(dev);
+
+fail_to_enable_clk:
+	return ret;
+}
+
+static void rk_platform_power_off_gpu(struct device *dev)
+{
+	rk_platform_disable_clk_gpu(dev);
+	rk_platform_disable_gpu_regulator(dev);
+}
+
+static int mali_runtime_suspend(struct device *device)
+{
+	int ret = 0;
+
+	MALI_DEBUG_PRINT(4, ("mali_runtime_suspend() called\n"));
+
+	if (device->driver &&
+	    device->driver->pm &&
+	    device->driver->pm->runtime_suspend) {
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->runtime_suspend(device);
+	}
+
+	if (!ret)
+		rk_platform_power_off_gpu(device);
+
+	return ret;
+}
+
+static int mali_runtime_resume(struct device *device)
+{
+	int ret = 0;
+
+	MALI_DEBUG_PRINT(4, ("mali_runtime_resume() called\n"));
+
+	rk_platform_power_on_gpu(device);
+
+	if (device->driver &&
+	    device->driver->pm &&
+	    device->driver->pm->runtime_resume) {
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->runtime_resume(device);
+	}
+
+	return ret;
+}
+
+static int mali_runtime_idle(struct device *device)
+{
+	int ret = 0;
+
+	MALI_DEBUG_PRINT(4, ("mali_runtime_idle() called\n"));
+
+	if (device->driver &&
+	    device->driver->pm &&
+	    device->driver->pm->runtime_idle) {
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->runtime_idle(device);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static int mali_os_suspend(struct device *device)
+{
+	int ret = 0;
+
+	MALI_DEBUG_PRINT(4, ("mali_os_suspend() called\n"));
+
+	if (device->driver &&
+	    device->driver->pm &&
+	    device->driver->pm->suspend) {
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->suspend(device);
+	}
+
+	if (!ret)
+		rk_platform_power_off_gpu(device);
+
+	return ret;
+}
+
+static int mali_os_resume(struct device *device)
+{
+	int ret = 0;
+
+	MALI_DEBUG_PRINT(4, ("mali_os_resume() called\n"));
+
+	rk_platform_power_on_gpu(device);
+
+	if (device->driver &&
+	    device->driver->pm &&
+	    device->driver->pm->resume) {
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->resume(device);
+	}
+
+	return ret;
+}
+
+static int mali_os_freeze(struct device *device)
+{
+	int ret = 0;
+
+	MALI_DEBUG_PRINT(4, ("mali_os_freeze() called\n"));
+
+	if (device->driver &&
+	    device->driver->pm &&
+	    device->driver->pm->freeze) {
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->freeze(device);
+	}
+
+	return ret;
+}
+
+static int mali_os_thaw(struct device *device)
+{
+	int ret = 0;
+
+	MALI_DEBUG_PRINT(4, ("mali_os_thaw() called\n"));
+
+	if (device->driver &&
+	    device->driver->pm &&
+	    device->driver->pm->thaw) {
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->thaw(device);
+	}
+
+	return ret;
+}
+
+static const struct dev_pm_ops mali_gpu_device_type_pm_ops = {
+	.suspend = mali_os_suspend,
+	.resume = mali_os_resume,
+	.freeze = mali_os_freeze,
+	.thaw = mali_os_thaw,
+#ifdef CONFIG_PM
+	.runtime_suspend = mali_runtime_suspend,
+	.runtime_resume = mali_runtime_resume,
+	.runtime_idle = mali_runtime_idle,
+#endif
+};
+
+static const struct device_type mali_gpu_device_device_type = {
+	.pm = &mali_gpu_device_type_pm_ops,
+};
+
+/*
+ * platform_specific_data of platform_device of mali_gpu.
+ */
+static const struct mali_gpu_device_data mali_gpu_data = {
+	.shared_mem_size = 256 * 1024 * 1024, /* 256MB */
+	.max_job_runtime = 60000, /* 60 seconds */
+#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_DEVFREQ_THERMAL)
+	.gpu_cooling_ops = &rk_cooling_ops,
+#endif
+};
+
+static void mali_platform_device_add_config(struct platform_device *pdev)
+{
+	pdev->name = MALI_GPU_NAME_UTGARD;
+	pdev->id = 0;
+	pdev->dev.type = &mali_gpu_device_device_type;
+	pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
+	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+}
+
+/*---------------------------------------------------------------------------*/
+/* platform_device_functions called by common_part. */
+
+int mali_platform_device_init(struct platform_device *pdev)
+{
+	int err = 0;
+
+	mali_platform_device_add_config(pdev);
+
+	//D("to add platform_specific_data to platform_device_of_mali.");
+	err = platform_device_add_data(pdev,
+				       &mali_gpu_data,
+				       sizeof(mali_gpu_data));
+	if (err) {
+		//E("fail to add platform_specific_data. err : %d.", err);
+		goto add_data_failed;
+	}
+
+	err = rk_context_init(pdev);
+	if (err) {
+		//E("fail to init rk_context. err : %d.", err);
+		goto init_rk_context_failed;
+	}
+
+#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_DEVFREQ_THERMAL)
+	err = power_model_simple_init(pdev);
+	if (err) {
+		//E("fail to init simple_power_model, err : %d.", err);
+		goto init_power_model_failed;
+	}
+#endif
+
+	return 0;
+
+#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_DEVFREQ_THERMAL)
+init_power_model_failed:
+	rk_context_deinit(pdev);
+#endif
+init_rk_context_failed:
+add_data_failed:
+	return err;
+}
+
+void mali_platform_device_deinit(struct platform_device *pdev)
+{
+	MALI_DEBUG_PRINT(4, ("mali_platform_device_unregister() called\n"));
+
+	rk_context_deinit(pdev);
+}
